<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>nse_daily.bse API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>nse_daily.bse</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># get bse daily bhav
# https://www.bseindia.com/download/BhavCopy/Equity/EQ130122_CSV.ZIP
from datetime import datetime, timedelta
from typing import Optional, Any

import requests
import os
from pathlib import Path
from requests.adapters import HTTPAdapter
from requests.packages.urllib3 import Retry
from numpy import random
from time import sleep
from multiprocessing.pool import ThreadPool

from nse_daily.common import _get_exception, _errorify
from fake_useragent import UserAgent


class BSEDaily(object):
    &#34;&#34;&#34;
    BSE Daily
    &#34;&#34;&#34;

    def __init__(self,
                 default_date_pattern: Optional[str] = &#39;%Y%m%d&#39;,
                 file_pattern: Optional[str] = &#34;EQ{date_part}_CSV.ZIP&#34;,
                 file_date_part_format: Optional[str] = &#39;%d%m%y&#39;,
                 uri_pattern: Optional[str] = &#34;https://www.bseindia.com/download/BhavCopy/Equity/{file_name}&#34;,
                 download_path: Optional[str] = None
                 ):
        &#34;&#34;&#34;
        BSE Daily bhav copy can be downloaded from the following
            URI: https://www.bseindia.com/download/BhavCopy/Equity/EQ130122_CSV.ZIP
        Parameters are set by default to match the above URI.
        If the URI Changes, please change the parameters below, to avoid breaking of code parameters.
        :param default_date_pattern: The default input date pattern to be used for parsing dates passed to the functions
        :param file_pattern: The pattern of the BSE Daily bhav file, i.e. for EQ130122_CSV.zip pass in EQ{date_part}_CSV.ZIP
        :param file_date_part_format: The date format of the date part in the DSE Daily bhav file pattern i.e. for 130122 pass in %d%m%y
        :param uri_pattern: The uri from where the BSE Daily bhav copy needs to be downloaded
        :param download_path: The local filesystem path where the BSE Daily bhav copy will be downloaded
        &#34;&#34;&#34;
        self.default_date_pattern = default_date_pattern
        self.file_pattern = file_pattern
        self.file_date_part_format = file_date_part_format
        self.uri_pattern = uri_pattern
        # self.uri_yy_mm_format = uri_yy_mm_format
        self.download_path = download_path
        if self.download_path is None or str(self.download_path).strip() == &#39;&#39;:
            appdir = str(Path.cwd())
            self.download_path = os.path.join(appdir, &#39;downloads&#39;)
        self._create_session()

    def _create_session(self):
        &#34;&#34;&#34;
        Function to create and set the requests.Session
        :return:
        &#34;&#34;&#34;
        self.session = requests.Session()
        retry = Retry(total=5,
                      read=5,
                      connect=5,
                      status_forcelist=(500, 502, 504),
                      method_whitelist=frozenset([&#39;GET&#39;, &#39;POST&#39;]),
                      backoff_factor=1
                      )
        adapter = HTTPAdapter(max_retries=retry)
        self.session.mount(&#39;http://&#39;, adapter)
        self.session.mount(&#39;https://&#39;, adapter)
        ua = UserAgent()
        self.session.headers.update({&#34;User-Agent&#34;: str(ua.chrome)})

    def _check_reponse(self, response: requests.Response):
        try:
            response.raise_for_status()
            return True
        except requests.exceptions.HTTPError:
            print(&#39;HTTP Error %s&#39;, response.reason)
            print(response.text)
            return False

    def _download_by_date(self, file_date: datetime) -&gt; (str, Any):
        &#34;&#34;&#34;
        Internal function to request the download for a single date. Function has a random uniform distribution sleep
        time between 1 to 3 seconds to avoid getting blocked during multiple concurrent requests. Function also
        checks and skips the download if date is a weekend.
        :param file_date: The date for which the download is being requested
        :return: (file_date, download_file_path)
        &#34;&#34;&#34;
        ################################################################################
        # Adding random sleep time to avoid being blocked for multiple requests
        sleep(random.uniform(1, 3))
        #########################################################################
        daynum = file_date.weekday()
        if daynum &gt;= 5:
            print(&#34;{} is weekend, file skipped&#34;.format(file_date.strftime(self.default_date_pattern)))
            return file_date, None
        file_date_str = file_date.strftime(self.file_date_part_format).upper()
        # nse_yy_mm = file_date.strftime(self.uri_yy_mm_format).upper()
        file_name = self.file_pattern.format(date_part=file_date_str)
        uri = self.uri_pattern.format(file_name=file_name)
        download_file_path = os.path.join(self.download_path, file_name)
        if not os.path.exists(self.download_path):
            os.makedirs(self.download_path)
        print(uri)
        response = self.session.request(method=&#39;GET&#39;, url=uri, allow_redirects=True)
        # r = requests.get(nse_uri, allow_redirects=True)
        status = self._check_reponse(response)
        if not status:
            return file_date, None
        content_type = response.headers.get(&#39;content-type&#39;)
        print(content_type)

        if content_type in [&#39;application/zip&#39;, &#39;application/x-zip-compressed&#39;, &#39;application/x-7z-compressed&#39;,
                            &#39;text/csv&#39;, &#39;application/gzip&#39;, &#39;application/x-tar&#39;, &#39;text/plain&#39;]:
            with open(download_file_path, &#39;wb&#39;) as file_pointer:
                file_pointer.write(response.content)
            print(&#34;{} download complete&#34;.format(file_name))
        else:
            e = _errorify(&#34;INVALID_CONTENT_TYPE&#34;,f&#34;content-type {content_type} being returned is not supported..&#34;)
            raise Exception(e)
        return file_date, download_file_path

    def download_by_date(self, date_str, date_format: Optional[str] = &#39;%Y%m%d&#39;):
        &#34;&#34;&#34;
        Function to download the BSE Daily bhav copy for a date
        :param date_str: Input date string i.e. &#39;20210105&#39; for 5th Jab 2021
        :param date_format: The date format of the input date string, default = &#39;%Y%m%d&#39;
        :return:
        &#34;&#34;&#34;
        try:
            file_date = datetime.strptime(date_str, date_format)
            return self._download_by_date(file_date)
        except:
            e = _get_exception()
            raise Exception(e)

    def download_by_date_range(self, date_start: str, date_end: str, date_format: Optional[str] = &#39;%Y%m%d&#39;,
                               num_workers: Optional[int] = 1):
        &#34;&#34;&#34;
        Function to download multiple Daily BSE bhav copies for a date range

        :param str date_start: The start date of the date range
        :param str date_end: The end date of the date range
        :param str date_format: The format of the input dates, default=&#39;%Y%m%d&#39;
        :param str num_workers: The number of workers to be utilized to get the files, default=1
        :return:
        &#34;&#34;&#34;
        try:
            start = datetime.strptime(date_start, date_format)
            end = datetime.strptime(date_end, date_format)
            l_dates = [start + timedelta(days=x) for x in range(0, (end - start).days)]
            tpool = ThreadPool(processes=num_workers)
            l_e = tpool.map(self._download_by_date, l_dates)
            return l_e
        except:
            e = _get_exception()
            raise Exception(e)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="nse_daily.bse.BSEDaily"><code class="flex name class">
<span>class <span class="ident">BSEDaily</span></span>
<span>(</span><span>default_date_pattern: Optional[str] = '%Y%m%d', file_pattern: Optional[str] = 'EQ{date_part}_CSV.ZIP', file_date_part_format: Optional[str] = '%d%m%y', uri_pattern: Optional[str] = 'https://www.bseindia.com/download/BhavCopy/Equity/{file_name}', download_path: Optional[str] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>BSE Daily</p>
<p>BSE Daily bhav copy can be downloaded from the following
URI: <a href="https://www.bseindia.com/download/BhavCopy/Equity/EQ130122_CSV.ZIP">https://www.bseindia.com/download/BhavCopy/Equity/EQ130122_CSV.ZIP</a>
Parameters are set by default to match the above URI.
If the URI Changes, please change the parameters below, to avoid breaking of code parameters.
:param default_date_pattern: The default input date pattern to be used for parsing dates passed to the functions
:param file_pattern: The pattern of the BSE Daily bhav file, i.e. for EQ130122_CSV.zip pass in EQ{date_part}_CSV.ZIP
:param file_date_part_format: The date format of the date part in the DSE Daily bhav file pattern i.e. for 130122 pass in %d%m%y
:param uri_pattern: The uri from where the BSE Daily bhav copy needs to be downloaded
:param download_path: The local filesystem path where the BSE Daily bhav copy will be downloaded</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BSEDaily(object):
    &#34;&#34;&#34;
    BSE Daily
    &#34;&#34;&#34;

    def __init__(self,
                 default_date_pattern: Optional[str] = &#39;%Y%m%d&#39;,
                 file_pattern: Optional[str] = &#34;EQ{date_part}_CSV.ZIP&#34;,
                 file_date_part_format: Optional[str] = &#39;%d%m%y&#39;,
                 uri_pattern: Optional[str] = &#34;https://www.bseindia.com/download/BhavCopy/Equity/{file_name}&#34;,
                 download_path: Optional[str] = None
                 ):
        &#34;&#34;&#34;
        BSE Daily bhav copy can be downloaded from the following
            URI: https://www.bseindia.com/download/BhavCopy/Equity/EQ130122_CSV.ZIP
        Parameters are set by default to match the above URI.
        If the URI Changes, please change the parameters below, to avoid breaking of code parameters.
        :param default_date_pattern: The default input date pattern to be used for parsing dates passed to the functions
        :param file_pattern: The pattern of the BSE Daily bhav file, i.e. for EQ130122_CSV.zip pass in EQ{date_part}_CSV.ZIP
        :param file_date_part_format: The date format of the date part in the DSE Daily bhav file pattern i.e. for 130122 pass in %d%m%y
        :param uri_pattern: The uri from where the BSE Daily bhav copy needs to be downloaded
        :param download_path: The local filesystem path where the BSE Daily bhav copy will be downloaded
        &#34;&#34;&#34;
        self.default_date_pattern = default_date_pattern
        self.file_pattern = file_pattern
        self.file_date_part_format = file_date_part_format
        self.uri_pattern = uri_pattern
        # self.uri_yy_mm_format = uri_yy_mm_format
        self.download_path = download_path
        if self.download_path is None or str(self.download_path).strip() == &#39;&#39;:
            appdir = str(Path.cwd())
            self.download_path = os.path.join(appdir, &#39;downloads&#39;)
        self._create_session()

    def _create_session(self):
        &#34;&#34;&#34;
        Function to create and set the requests.Session
        :return:
        &#34;&#34;&#34;
        self.session = requests.Session()
        retry = Retry(total=5,
                      read=5,
                      connect=5,
                      status_forcelist=(500, 502, 504),
                      method_whitelist=frozenset([&#39;GET&#39;, &#39;POST&#39;]),
                      backoff_factor=1
                      )
        adapter = HTTPAdapter(max_retries=retry)
        self.session.mount(&#39;http://&#39;, adapter)
        self.session.mount(&#39;https://&#39;, adapter)
        ua = UserAgent()
        self.session.headers.update({&#34;User-Agent&#34;: str(ua.chrome)})

    def _check_reponse(self, response: requests.Response):
        try:
            response.raise_for_status()
            return True
        except requests.exceptions.HTTPError:
            print(&#39;HTTP Error %s&#39;, response.reason)
            print(response.text)
            return False

    def _download_by_date(self, file_date: datetime) -&gt; (str, Any):
        &#34;&#34;&#34;
        Internal function to request the download for a single date. Function has a random uniform distribution sleep
        time between 1 to 3 seconds to avoid getting blocked during multiple concurrent requests. Function also
        checks and skips the download if date is a weekend.
        :param file_date: The date for which the download is being requested
        :return: (file_date, download_file_path)
        &#34;&#34;&#34;
        ################################################################################
        # Adding random sleep time to avoid being blocked for multiple requests
        sleep(random.uniform(1, 3))
        #########################################################################
        daynum = file_date.weekday()
        if daynum &gt;= 5:
            print(&#34;{} is weekend, file skipped&#34;.format(file_date.strftime(self.default_date_pattern)))
            return file_date, None
        file_date_str = file_date.strftime(self.file_date_part_format).upper()
        # nse_yy_mm = file_date.strftime(self.uri_yy_mm_format).upper()
        file_name = self.file_pattern.format(date_part=file_date_str)
        uri = self.uri_pattern.format(file_name=file_name)
        download_file_path = os.path.join(self.download_path, file_name)
        if not os.path.exists(self.download_path):
            os.makedirs(self.download_path)
        print(uri)
        response = self.session.request(method=&#39;GET&#39;, url=uri, allow_redirects=True)
        # r = requests.get(nse_uri, allow_redirects=True)
        status = self._check_reponse(response)
        if not status:
            return file_date, None
        content_type = response.headers.get(&#39;content-type&#39;)
        print(content_type)

        if content_type in [&#39;application/zip&#39;, &#39;application/x-zip-compressed&#39;, &#39;application/x-7z-compressed&#39;,
                            &#39;text/csv&#39;, &#39;application/gzip&#39;, &#39;application/x-tar&#39;, &#39;text/plain&#39;]:
            with open(download_file_path, &#39;wb&#39;) as file_pointer:
                file_pointer.write(response.content)
            print(&#34;{} download complete&#34;.format(file_name))
        else:
            e = _errorify(&#34;INVALID_CONTENT_TYPE&#34;,f&#34;content-type {content_type} being returned is not supported..&#34;)
            raise Exception(e)
        return file_date, download_file_path

    def download_by_date(self, date_str, date_format: Optional[str] = &#39;%Y%m%d&#39;):
        &#34;&#34;&#34;
        Function to download the BSE Daily bhav copy for a date
        :param date_str: Input date string i.e. &#39;20210105&#39; for 5th Jab 2021
        :param date_format: The date format of the input date string, default = &#39;%Y%m%d&#39;
        :return:
        &#34;&#34;&#34;
        try:
            file_date = datetime.strptime(date_str, date_format)
            return self._download_by_date(file_date)
        except:
            e = _get_exception()
            raise Exception(e)

    def download_by_date_range(self, date_start: str, date_end: str, date_format: Optional[str] = &#39;%Y%m%d&#39;,
                               num_workers: Optional[int] = 1):
        &#34;&#34;&#34;
        Function to download multiple Daily BSE bhav copies for a date range

        :param str date_start: The start date of the date range
        :param str date_end: The end date of the date range
        :param str date_format: The format of the input dates, default=&#39;%Y%m%d&#39;
        :param str num_workers: The number of workers to be utilized to get the files, default=1
        :return:
        &#34;&#34;&#34;
        try:
            start = datetime.strptime(date_start, date_format)
            end = datetime.strptime(date_end, date_format)
            l_dates = [start + timedelta(days=x) for x in range(0, (end - start).days)]
            tpool = ThreadPool(processes=num_workers)
            l_e = tpool.map(self._download_by_date, l_dates)
            return l_e
        except:
            e = _get_exception()
            raise Exception(e)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="nse_daily.bse.BSEDaily.download_by_date"><code class="name flex">
<span>def <span class="ident">download_by_date</span></span>(<span>self, date_str, date_format: Optional[str] = '%Y%m%d')</span>
</code></dt>
<dd>
<div class="desc"><p>Function to download the BSE Daily bhav copy for a date
:param date_str: Input date string i.e. '20210105' for 5th Jab 2021
:param date_format: The date format of the input date string, default = '%Y%m%d'
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_by_date(self, date_str, date_format: Optional[str] = &#39;%Y%m%d&#39;):
    &#34;&#34;&#34;
    Function to download the BSE Daily bhav copy for a date
    :param date_str: Input date string i.e. &#39;20210105&#39; for 5th Jab 2021
    :param date_format: The date format of the input date string, default = &#39;%Y%m%d&#39;
    :return:
    &#34;&#34;&#34;
    try:
        file_date = datetime.strptime(date_str, date_format)
        return self._download_by_date(file_date)
    except:
        e = _get_exception()
        raise Exception(e)</code></pre>
</details>
</dd>
<dt id="nse_daily.bse.BSEDaily.download_by_date_range"><code class="name flex">
<span>def <span class="ident">download_by_date_range</span></span>(<span>self, date_start: str, date_end: str, date_format: Optional[str] = '%Y%m%d', num_workers: Optional[int] = 1)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to download multiple Daily BSE bhav copies for a date range</p>
<p>:param str date_start: The start date of the date range
:param str date_end: The end date of the date range
:param str date_format: The format of the input dates, default='%Y%m%d'
:param str num_workers: The number of workers to be utilized to get the files, default=1
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_by_date_range(self, date_start: str, date_end: str, date_format: Optional[str] = &#39;%Y%m%d&#39;,
                           num_workers: Optional[int] = 1):
    &#34;&#34;&#34;
    Function to download multiple Daily BSE bhav copies for a date range

    :param str date_start: The start date of the date range
    :param str date_end: The end date of the date range
    :param str date_format: The format of the input dates, default=&#39;%Y%m%d&#39;
    :param str num_workers: The number of workers to be utilized to get the files, default=1
    :return:
    &#34;&#34;&#34;
    try:
        start = datetime.strptime(date_start, date_format)
        end = datetime.strptime(date_end, date_format)
        l_dates = [start + timedelta(days=x) for x in range(0, (end - start).days)]
        tpool = ThreadPool(processes=num_workers)
        l_e = tpool.map(self._download_by_date, l_dates)
        return l_e
    except:
        e = _get_exception()
        raise Exception(e)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="nse_daily" href="../index.html">nse_daily</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="nse_daily.bse.BSEDaily" href="#nse_daily.bse.BSEDaily">BSEDaily</a></code></h4>
<ul class="">
<li><code><a title="nse_daily.bse.BSEDaily.download_by_date" href="#nse_daily.bse.BSEDaily.download_by_date">download_by_date</a></code></li>
<li><code><a title="nse_daily.bse.BSEDaily.download_by_date_range" href="#nse_daily.bse.BSEDaily.download_by_date_range">download_by_date_range</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>